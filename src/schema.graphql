# Exposes a URL that specifies the behaviour of this scalar.
directive @specifiedBy(
  # The URL that specifies the behaviour of this scalar.
  url: String!
) on SCALAR

#  see also https://github.com/graphql-java/graphql-java-extended-validation/blob/master/README.md
directive @DecimalMax(
  value: String!
  inclusive: Boolean! = true
  message: String = "graphql.validation.DecimalMax.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @DecimalMin(
  value: String!
  inclusive: Boolean! = true
  message: String = "graphql.validation.DecimalMin.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Max(
  value: Int! = 2147483647
  message: String = "graphql.validation.Max.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Min(
  value: Int! = 0
  message: String = "graphql.validation.Min.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Negative(
  message: String = "graphql.validation.Negative.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @NegativeOrZero(
  message: String = "graphql.validation.NegativeOrZero.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @NotBlank(
  message: String = "graphql.validation.NotBlank.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @NotEmpty(
  message: String = "graphql.validation.NotEmpty.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @ContainerNotEmpty(
  message: String = "graphql.validation.ContainerNotEmpty.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Pattern(
  regexp: String! = ".*"
  message: String = "graphql.validation.Pattern.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Positive(
  message: String = "graphql.validation.Positive.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @PositiveOrZero(
  message: String = "graphql.validation.PositiveOrZero.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Range(
  min: Int = 0
  max: Int = 2147483647
  message: String = "graphql.validation.Range.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Size(
  min: Int = 0
  max: Int = 2147483647
  message: String = "graphql.validation.Size.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @ContainerSize(
  min: Int = 0
  max: Int = 2147483647
  message: String = "graphql.validation.ContainerSize.message"
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @resolveTo(
  requiredSelectionSet: String
  sourceName: String!
  sourceTypeName: String!
  sourceFieldName: String!
  sourceSelectionSet: String
  sourceArgs: ResolveToSourceArgs
  keyField: String
  keysArg: String
  pubsubTopic: String
  filterBy: String
  additionalArgs: ResolveToSourceArgs
  result: String
  resultType: String
) on FIELD_DEFINITION

interface Assessment {
  # Assessment metadata
  assessmentMetadata: AssessmentMetadata!

  # ID of the content
  id: UUID!

  # Metadata of the content
  metadata: ContentMetadata!

  # Progress data of the content for the current user.
  userProgressData: UserProgressData!

  # Progress data of the specified user.
  progressDataForUser(userId: UUID!): UserProgressData!
}

type AssessmentMetadata {
  # Number of skill points a student receives for completing this content
  skillPoints: Int!

  # Type of the assessment
  skillTypes: [SkillType!]!

  # The initial learning interval for the assessment in days.
  # This is the interval that is applied after the assessment is completed the first time.
  # Following intervals are calculated based on the previous interval and the user's performance.
  # If this is null, the assessment will never be scheduled for review, which
  # is useful for assessments that are not meant to be repeated.
  initialLearningInterval: Int
}

input AssessmentMetadataInput {
  # Number of skill points a student receives for completing this content
  skillPoints: Int!

  # Type of the assessment
  skillTypes: [SkillType!]!

  # The initial learning interval for the assessment in days.
  # This is the interval that is applied after the assessment is completed the first time.
  # Following intervals are calculated based on the previous interval and the user's performance.
  # If this is null, the assessment will never be scheduled for review, which
  # is useful for assessments that are not meant to be repeated.
  initialLearningInterval: Int
}

input AssociationInput {
  # Text of the left side of the association, in SlateJS JSON format.
  left: String!

  # Text of the right side of the association, in SlateJS JSON format.
  right: String!

  # Feedback for the association when the user selects a wrong answer, in SlateJS JSON format.
  feedback: JSON
}

# Association question, i.e., a question where the user has to assign the correct right side to each left side.
type AssociationQuestion implements Question {
  # Text to display above the association question, in SlateJS JSON format.
  text: JSON!

  # List of correct associations.
  correctAssociations: [SingleAssociation!]!

  # Computed list of all the left sides of the associations, shuffled.
  leftSide: [String!]!

  # Computed list of all the right sides of the associations, shuffled.
  rightSide: [String!]!

  # Unique identifier of the question.
  id: UUID!

  # Number of the question, i.e., the position of the question in the list of questions.
  # Only relevant if questionPoolingMode is ORDERED.
  number: Int!

  # Type of the question.
  type: QuestionType!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

# A chapter is a part of a course.
type Chapter {
  # UUID of the chapter, generated automatically
  id: UUID!

  # Title of the chapter, maximum length is 255 characters.
  title: String!

  # Description of the chapter, maximum length is 3000 characters.
  description: String!

  # Number of the chapter, determines the order of the chapters.
  number: Int!

  # Start date of the chapter, ISO 8601 format.
  startDate: DateTime!

  # End date of the chapter, ISO 8601 format.
  endDate: DateTime!

  # Suggested Start date to start the chapter, ISO 8601 format.
  # Must be after Start Date and before the End dates.
  suggestedStartDate: DateTime

  # Suggested End date of the chapter, ISO 8601 format.
  # Must be after the Start Dates and before the End dates.
  suggestedEndDate: DateTime

  # The course the chapter belongs to.
  course: Course!
  contents: [Content!]!
  sections: [Section!]!
  skillLevels: SkillLevels!

  # The skill types which are achievable in this chapter.
  # A skill type is achievable if there is at least one assessment in this chapter with this skill type.
  achievableSkillTypes: [SkillType]!
}

input ChapterFilter {
  title: StringFilter
  description: StringFilter
  number: IntFilter
  startDate: DateTimeFilter
  endDate: DateTimeFilter
  suggestedStartDate: DateTimeFilter
  suggestedEndDate: DateTimeFilter
  and: [ChapterFilter!]
  or: [ChapterFilter!]
  not: ChapterFilter
}

# Return type of the chapters query, contains a list of chapters and pagination info.
type ChapterPayload {
  elements: [Chapter!]!
  pagination: PaginationInfo!
}

type ClozeBlankElement {
  # The correct answer for the blank.
  correctAnswer: String!

  # Feedback for the blank when the user selects a wrong answer, in SlateJS JSON format.
  feedback: JSON
}

union ClozeElement = ClozeTextElement | ClozeBlankElement

input ClozeElementInput {
  # Type of the element.
  type: ClozeElementType!

  # Text of the element. Only used for TEXT type.
  text: JSON

  # The correct answer for the blank. Only used for BLANK type.
  correctAnswer: String

  # Feedback for the blank when the user selects a wrong answer, in SlateJS JSON format. Only used for BLANK type.
  feedback: JSON
}

enum ClozeElementType {
  TEXT
  BLANK
}

type ClozeQuestion implements Question {
  # The elements of the cloze question.
  clozeElements: [ClozeElement!]!

  # Addtional wrong answers for the blanks.
  additionalWrongAnswers: [String!]!

  # All selectable answers for the blanks (computed). This contains the correct answers as well as wrong answers.
  allBlanks: [String!]!

  # Whether the blanks must be answered in free text or by selecting the correct answer from a list.
  showBlanksList: Boolean!

  # Unique identifier of the question.
  id: UUID!

  # Number of the question, i.e., the position of the question in the list of questions.
  # Only relevant if questionPoolingMode is ORDERED.
  number: Int!

  # Type of the question.
  type: QuestionType!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

type ClozeTextElement {
  # Text of the element, in SlateJS JSON format.
  text: JSON!
}

type CompositeProgressInformation {
  # percentage of completedContents/totalContents
  progress: Float!

  # absolut number of completed content
  completedContents: Int!

  # absolut number of total content
  totalContents: Int!
}

interface Content {
  # ID of the content
  id: UUID!

  # Metadata of the content
  metadata: ContentMetadata!

  # Progress data of the content for the current user.
  userProgressData: UserProgressData!

  # Progress data of the specified user.
  progressDataForUser(userId: UUID!): UserProgressData!
}

type ContentMetadata {
  # Name of the content
  name: String!

  # Content type
  type: ContentType!

  # Suggested date when the content should be done
  suggestedDate: DateTime!

  # Number of reward points a student receives for completing this content
  rewardPoints: Int!

  # ID of the chapter this content is associated with
  chapterId: UUID!

  # TagNames this content is tagged with
  tagNames: [String!]!
}

type ContentMutation {
  # Identifier of Content
  contentId: UUID!

  # Update an existing Content
  updateMediaContent(input: UpdateMediaContentInput!): MediaContent!

  # Update an existing Assessment
  updateAssessment(input: UpdateAssessmentInput!): Assessment!

  # Delete an existing Content, throws an error if no Content with the given id exists
  deleteContent: UUID!

  # Add a tag to an existing content
  addTagToContent(tagName: String): Content!

  # Remove a tag from an existing content
  removeTagFromContent(tagName: String): Content!
}

type ContentPayload {
  # the contents
  elements: [Content!]!

  # pagination info
  pageInfo: PaginationInfo!
}

# Type of the content
enum ContentType {
  MEDIA
  FLASHCARDS
  QUIZ
}

# Courses are the main entity of the application. They are the top level of the
# hierarchy and contain chapters.
type Course {
  # UUID of the course. Generated automatically when creating a new course.
  id: UUID!

  # Title of the course. Maximal length is 255 characters, must not be blank.
  title: String!

  # Detailed description of the course. Maximal length is 3000 characters.
  description: String!

  # Start date of the course, ISO 8601 format.
  # Users can only access the course and work on course content after the start date.
  # Must be before the end date.
  startDate: DateTime!

  # End date of the course, ISO 8601 format.
  # Users can no longer access the course and work on course content after the end date.
  # Must be after the start date.
  endDate: DateTime!

  # Published state of the course. If the course is published, it is visible to users.
  published: Boolean!

  # The year in which the term starts.
  startYear: Int

  # The division of the academic calendar in which the term takes place.
  yearDivision: YearDivision

  # Chapters of the course. Can be filtered and sorted.
  chapters(
    filter: ChapterFilter

    # The fields to sort by. The default sort order is by chapter number.
    # Throws an error if no field with the given name exists.
    sortBy: [String!]! = []

    # The sort direction for each field. If not specified, defaults to ASC.
    sortDirection: [SortDirection!]! = [ASC]
    pagination: Pagination
  ): ChapterPayload!
  rewardScores: RewardScores!
  scoreboard: [ScoreboardItem!]!

  # Suggests content of the course which the current user should
  # learn next (both new content and content to repeat).
  suggestions(
    # The amount of suggestions to generate in total.
    amount: Int!

    # Only suggestions for these skill types will be generated.
    # If no skill types are given, suggestions for all skill types will be generated,
    # also containing suggestions for media content (which do not have a skill type).
    skillTypes: [SkillType!]! = []
  ): [Suggestion!]!
}

# Input type for filtering courses. All fields are optional.
# If multiple filters are specified, they are combined with AND (except for the or field).
input CourseFilter {
  title: StringFilter
  description: StringFilter
  startDate: DateTimeFilter
  endDate: DateTimeFilter
  published: Boolean
  and: [CourseFilter!]
  or: [CourseFilter!]
  not: CourseFilter
}

# Represents a course membership object of a user. Each user can be a member of
# set of courses and some users can also own courses
type CourseMembership {
  # Id of the user.
  userId: UUID!

  # Id of the course the user is a member of.
  courseId: UUID!

  # The role of the user in the course.
  role: UserRoleInCourse!
  course: Course!
}

# Represents a course membership input object of a user.
input CourseMembershipInput {
  # Id of the user.
  userId: UUID!

  # Id of the course the user is a member of.
  courseId: UUID!

  # The role of the user in the course.
  role: UserRoleInCourse!
}

# Return type for the course query. Contains the course and the pagination info.
type CoursePayload {
  elements: [Course!]!
  pagination: PaginationInfo!
}

# Resources are all types of content present in a course. Each resource can be available or unavailable in a course.
type CourseResourceAssociation {
  # UUID of the resource.
  id: UUID!

  # A list of course IDs a resource is presently available in
  availableCourses: [UUID!]!

  # A list of course IDs a resource is presently unavailable in
  unAvailableCourses: [UUID!]!
}

input CreateAssessmentInput {
  # Metadata for the new Content
  metadata: CreateContentMetadataInput!

  # Assessment metadata
  assessmentMetadata: AssessmentMetadataInput!
}

input CreateAssociationQuestionInput {
  # Number of the question, used for ordering.
  # This can be omitted, in which case a number, one higher than the highest number of the existing questions, will be used.
  number: Int

  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # List of associations.
  correctAssociations: [AssociationInput!]!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

# Input type for creating chapters.
input CreateChapterInput {
  # Title of the chapter, maximum length is 255 characters, must not be blank.
  title: String!

  # Description of the chapter, maximum length is 3000 characters.
  description: String!

  # Number of the chapter, determines the order of the chapters, must be positive.
  number: Int!

  # Start date of the chapter, ISO 8601 format.
  # Must be before the end date.
  startDate: DateTime!

  # End date of the chapter, ISO 8601 format.
  # Must be after the start date.
  endDate: DateTime!

  # Suggested Start date to start the chapter, ISO 8601 format.
  # Must be after Start Date and before the End dates.
  suggestedStartDate: DateTime

  # Suggested End date of the chapter, ISO 8601 format.
  # Must be after the Start Dates and before the End dates.
  suggestedEndDate: DateTime

  # ID of the course the chapter belongs to.
  # Must be a UUID of an existing course.
  courseId: UUID!
}

input CreateClozeQuestionInput {
  # Number of the question, used for ordering.
  # This can be omitted, in which case a number, one higher than the highest number of the existing questions, will be used.
  number: Int

  # List of cloze elements.
  clozeElements: [ClozeElementInput!]!

  # List of additional wrong answers.
  additionalWrongAnswers: [String!]! = []

  # If true, the list of possible answers will be shown to the user.
  showBlanksList: Boolean! = true

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

input CreateContentMetadataInput {
  # Name of the content
  name: String!

  # Type of the content
  type: ContentType!

  # Suggested date when the content should be done
  suggestedDate: DateTime!

  # Number of reward points a student receives for completing this content
  rewardPoints: Int!

  # ID of the chapter this content is associated with
  chapterId: UUID!

  # TagNames this content is tagged with
  tagNames: [String!]! = []
}

# Input type for creating a new course. See also on the course type for detailed field descriptions.
input CreateCourseInput {
  # Title of the course, max 255 characters, must not be blank.
  title: String!

  # Description of the course, max 3000 characters.
  description: String!

  # Start date of the course, ISO 8601 format.
  # Must be before the end date.
  startDate: DateTime!

  # End date of the course, ISO 8601 format.
  # Must be after the start date.
  endDate: DateTime!

  # Published status of the course.
  published: Boolean!

  # The year in which the term starts.
  startYear: Int

  # The division of the academic calendar in which the term takes place.
  yearDivision: YearDivision
}

input CreateExactAnswerQuestionInput {
  # Number of the question, used for ordering.
  # This can be omitted, in which case a number, one higher than the highest number of the existing questions, will be used.
  number: Int

  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # If the answer is case sensitive. If true, the answer is checked case sensitive.
  caseSensitive: Boolean! = false

  # A list of possible correct answers.
  correctAnswers: [String!]!

  # Feedback for the question when the user enters a wrong answer, in SlateJS JSON format.
  feedback: JSON

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

input CreateFlashcardInput {
  # List of sides of this flashcard. Must be at least two sides.
  sides: [FlashcardSideInput!]!
}

input CreateFlashcardSetInput {
  # List of flashcards in this set.
  flashcards: [CreateFlashcardInput!]!
}

# Input for creating new media content. Media specific fields are stored in the Media Service.
input CreateMediaContentInput {
  # Metadata for the new Content
  metadata: CreateContentMetadataInput!
}

input CreateMediaRecordInput {
  # Name of the media record. Cannot be blank, maximum length 255 characters.
  name: String!

  # Type of the media record.
  type: MediaType!

  # IDs of the MediaContents this media record is associated with
  contentIds: [UUID!]!
}

input CreateMultipleChoiceQuestionInput {
  # Number of the question, used for ordering.
  # This can be omitted, in which case a number, one higher than the highest number of the existing questions, will be used.
  number: Int

  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # List of answers.
  answers: [MultipleChoiceAnswerInput!]!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

input CreateNumericQuestionInput {
  # Number of the question, used for ordering.
  # This can be omitted, in which case a number, one higher than the highest number of the existing questions, will be used.
  number: Int

  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # The correct answer for the question.
  correctAnswer: Float!

  # The allowed deviation from the correct answer.
  tolerance: Float!

  # Feedback for the question when the user enters a wrong answer, in SlateJS JSON format.
  feedback: JSON

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

input CreateQuizInput {
  # Threshold of the quiz, i.e., how many questions the user has to answer correctly to pass the quiz.
  #
  # If this is greater than the number of questions, the behavior is the same
  # as if it was equal to the number of questions.
  requiredCorrectAnswers: Int!

  # Question pooling mode of the quiz.
  questionPoolingMode: QuestionPoolingMode!

  # Number of questions that are randomly selected from the list of questions.
  # Should only be set if questionPoolingMode is RANDOM.
  #
  # If this is greater than the number of questions, the behavior is the same
  # as if it was equal to the number of questions.
  #
  # If this is null or not set, the behavior is the same as if it was equal to the number of questions.
  numberOfRandomlySelectedQuestions: Int
}

input CreateSectionInput {
  # Chapter Section will belong to
  chapterId: UUID!

  # name given to Section
  name: String!
}

input CreateSelfAssessmentQuestionInput {
  # Number of the question, used for ordering.
  # This can be omitted, in which case a number, one higher than the highest number of the existing questions, will be used.
  number: Int

  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # A possible correct answer to the question.
  solutionSuggestion: JSON!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

input CreateStageInput {
  # updated List of UUIDs for content labeled as required in this Stage
  requiredContents: [UUID!]!

  # updated List of UUIDs for content labeled as optional in this Stage
  optionalContents: [UUID!]!
}

# An RFC-3339 compliant Full Date Scalar
scalar Date

# A slightly refined version of RFC-3339 compliant DateTime Scalar
scalar DateTime

# Filter for date values.
# If multiple filters are specified, they are combined with AND.
input DateTimeFilter {
  # If specified, filters for dates after the specified value.
  after: DateTime

  # If specified, filters for dates before the specified value.
  before: DateTime
}

# A question with a clear, correct answer that can be automatically checked.
# Differs from self-assessment questions in that the user has to enter one of the correct answers and
# the answer is checked automatically.
type ExactAnswerQuestion implements Question {
  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # A list of possible correct answers. The user has to enter one of these answers.
  correctAnswers: [String!]!

  # If the answer is case sensitive. If true, the answer is checked case sensitive.
  caseSensitive: Boolean!

  # Feedback for the question when the user enters a wrong answer, in SlateJS JSON format.
  feedback: JSON

  # Unique identifier of the question.
  id: UUID!

  # Number of the question, i.e., the position of the question in the list of questions.
  # Only relevant if questionPoolingMode is ORDERED.
  number: Int!

  # Type of the question.
  type: QuestionType!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

# A flashcard is a set of two or more sides. Each side has a label and a text.
# The label is used to specify which side of the flashcard is being shown to the user first for learning
# and which sides he has to guess.
type Flashcard {
  # Unique identifier of this flashcard.
  id: UUID!

  # List of sides of this flashcard.
  sides: [FlashcardSide!]!

  # Progress data of the flashcard, specific to given users.
  # If userId is not provided, the progress data of the current user is returned.
  userProgressData: FlashcardProgressData!
}

type FlashcardProgressData {
  # The date the user learned the flashcard.
  # This is null it the user has not learned the content item once.
  lastLearned: DateTime

  # The learning interval in days for the content item.
  learningInterval: Int

  # The next time the content should be learned.
  # Calculated using the date the user completed the content item and the learning interval.
  # This is null if the user has not completed the content item once.
  nextLearn: DateTime
}

type FlashcardProgressDataLog {
  # The id of the Log
  id: UUID

  # The date the user learned the flashcard.
  learnedAt: DateTime!

  # Whether the user knew the flashcard or not.
  success: Boolean!
}

# A set of flashcards. A flashcard set belongs to exactly one assessment. Therefore, the uuid of the assessment
# also serves as the identifier of a flashcard set.
type FlashcardSet {
  # The uuid of the assessment this flashcard set belongs to.
  # This also serves as the identifier of this flashcard set.
  assessmentId: UUID!

  # List of flashcards in this set.
  flashcards: [Flashcard!]!

  # The assessment this FlashcardSet belongs to.
  assessment: FlashcardSetAssessment
}

# A set of flashcards, flashcard related fields are stored in the flashcard service.
type FlashcardSetAssessment implements Assessment & Content {
  # Assessment metadata
  assessmentMetadata: AssessmentMetadata!

  # ID of the content
  id: UUID!

  # Metadata of the content
  metadata: ContentMetadata!

  # Progress data of the content for the current user.
  userProgressData: UserProgressData!

  # Progress data of the specified user.
  progressDataForUser(userId: UUID!): UserProgressData!

  # The FlashcardSet of the assessment.
  flashcardSet: FlashcardSet
}

type FlashcardSetMutation {
  # ID of the flashcard set that is being modified.
  assessmentId: UUID!

  # Creates a new flashcard. Throws an error if the flashcard set does not exist.
  createFlashcard(input: CreateFlashcardInput!): Flashcard!

  # Updates a flashcard. Throws an error if the flashcard does not exist.
  updateFlashcard(input: UpdateFlashcardInput!): Flashcard!

  # Deletes the flashcard with the specified ID. Throws an error if the flashcard does not exist.
  deleteFlashcard(id: UUID!): UUID!
}

type FlashcardSide {
  # Text of this flashcard side as rich text in SlateJS json.
  text: JSON!

  # Label of this flashcard side. E.g. "Front" or "Back", or "Question" or "Answer".
  label: String!

  # Whether this side is a question, i.e. should be shown to the user to guess the other sides or not.
  isQuestion: Boolean!

  # Whether this side is also an answer. Some Flashcards can have their sides be
  # used as both questions or answers for the other sides
  isAnswer: Boolean!
}

input FlashcardSideInput {
  # Text of this flashcard side.
  text: JSON!

  # Label of this flashcard side. E.g. "Front" or "Back", or "Question" or "Answer".
  label: String!

  # Whether this side is a question, i.e. should be shown to the user to guess the other sides or not.
  isQuestion: Boolean!

  # Whether this side is also an answer. Some Flashcards can have their sides be
  # used as both questions or answers for the other sides
  isAnswer: Boolean!
}

# Filter for integer values.
# If multiple filters are specified, they are combined with AND.
input IntFilter {
  # An integer value to match exactly.
  equals: Int

  # If specified, filters for values greater than to the specified value.
  greaterThan: Int

  # If specified, filters for values less than to the specified value.
  lessThan: Int
}

# A JSON scalar
scalar JSON

# 24-hour clock time value string in the format `hh:mm:ss` or `hh:mm:ss.sss`.
scalar LocalTime

input LogFlashcardLearnedInput {
  # The id of the flashcard that was learned.
  flashcardId: UUID!

  # If the user knew the flashcard or not.
  successful: Boolean!
}

input LogFlashcardSetLearnedInput {
  # The id of the flashcard that was learned.
  flashcardSetId: UUID!

  # The id of the user that learned the flashcard.
  userId: UUID!

  # The percentage of flashcards in the set that the user knew.
  percentageSuccess: Float!
}

type MediaContent implements Content {
  # ID of the content
  id: UUID!

  # Metadata of the content
  metadata: ContentMetadata!

  # Progress data of the content for the current user.
  userProgressData: UserProgressData!

  # Progress data of the specified user.
  progressDataForUser(userId: UUID!): UserProgressData!

  # The media records linked to this media content.
  mediaRecords: [MediaRecord!]!
}

#  schema file of the microservice
#  defines data types, queries and mutations
#  this can be done in a separate files as long as they are in this folder and
#  end with .graphqls
type MediaRecord {
  # ID of the media record
  id: UUID!

  # Name of the media record
  name: String!

  # User ID of the creator of the media record.
  creatorId: UUID!

  # Type of the media record
  type: MediaType!

  # IDs of the MediaContents this media record is associated with
  contentIds: [UUID!]!

  # Temporary upload url for the media record
  uploadUrl: String!

  # Temporary download url for the media record
  downloadUrl: String!

  # The progress data of the given user for this medium.
  userProgressData: MediaRecordProgressData!
}

type MediaRecordProgressData {
  # Whether the medium has been worked on by the user.
  workedOn: Boolean!

  # Date on which the medium was worked on by the user.
  # This is null if the medium has not been worked on by the user.
  dateWorkedOn: DateTime
}

# The type of the media record
enum MediaType {
  VIDEO
  AUDIO
  IMAGE
  PRESENTATION
  DOCUMENT
  URL
}

type MultipleChoiceAnswer {
  # Text of the answer, in SlateJS JSON format.
  answerText: JSON!

  # Whether the answer is correct or not.
  correct: Boolean!

  # Feedback for when the user selects this answer, in SlateJS JSON format.
  feedback: JSON
}

input MultipleChoiceAnswerInput {
  # Text of the answer, in SlateJS JSON format.
  answerText: JSON!

  # Whether the answer is correct or not.
  correct: Boolean!

  # Feedback for when the user selects this answer, in SlateJS JSON format.
  feedback: JSON
}

# Multiple choice question, i.e., a question with multiple answers of which the user has to select the correct ones.
type MultipleChoiceQuestion implements Question {
  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # List of answers.
  answers: [MultipleChoiceAnswer!]!

  # How many answers the user has to select. This is computed from the list of answers.
  numberOfCorrectAnswers: Int!

  # Unique identifier of the question.
  id: UUID!

  # Number of the question, i.e., the position of the question in the list of questions.
  # Only relevant if questionPoolingMode is ORDERED.
  number: Int!

  # Type of the question.
  type: QuestionType!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

type Mutation {
  # Create new media content
  createMediaContent(input: CreateMediaContentInput!): MediaContent!

  # Create a new Assessment
  createAssessment(input: CreateAssessmentInput!): Assessment!

  # Modify Content
  mutateContent(contentId: UUID!): ContentMutation!

  # Create new Section
  createSection(input: CreateSectionInput!): Section!

  # Modify Sections
  mutateSection(sectionId: UUID!): SectionMutation!

  # ONLY FOR TESTING PURPOSES. DO NOT USE IN FRONTEND. WILL BE REMOVED.
  #
  # Triggers the recalculation of the skill level of the user.
  # This is done automatically at some time in the night.
  #
  # The purpose of this mutation is to allow testing of the skill level score and demonstrate the functionality.
  recalculateLevels(chapterId: UUID!, userId: UUID!): SkillLevels!
    @deprecated(reason: "Only for testing purposes. Will be removed.")

  # Create a quiz.
  createQuiz(assessmentId: UUID!, input: CreateQuizInput!): Quiz!

  # Modify a quiz.
  mutateQuiz(assessmentId: UUID!): QuizMutation!

  # Delete a quiz.
  deleteQuiz(assessmentId: UUID!): UUID!
    @deprecated(
      reason: "Only for development, will be removed in production. Use deleteAssessment in contents service instead."
    )

  # Log that a multiple choice quiz is completed.
  logQuizCompleted(input: QuizCompletedInput!): Quiz!

  # Creates a new flashcard set.
  createFlashcardSet(
    assessmentId: UUID!
    input: CreateFlashcardSetInput!
  ): FlashcardSet!

  # Deletes a flashcard set. Throws an error if the flashcard set does not exist.
  # The contained flashcards are deleted as well.
  deleteFlashcardSet(input: UUID!): UUID!
    @deprecated(
      reason: "Only for development, will be removed in production. Use deleteAssessment in contents service instead."
    )

  # Modify a flashcard set.
  mutateFlashcardSet(assessmentId: UUID!): FlashcardSetMutation!

  # Logs that a user has learned a flashcard.
  logFlashcardLearned(input: LogFlashcardLearnedInput!): Flashcard!

  # ONLY FOR TESTING PURPOSES. DO NOT USE IN FRONTEND. WILL BE REMOVED.
  #
  # Triggers the recalculation of the reward score of the user.
  # This is done automatically at some time in the night.
  #
  # The purpose of this mutation is to allow testing of the reward score and demonstrate the functionality.
  recalculateScores(courseId: UUID!, userId: UUID!): RewardScores!
    @deprecated(reason: "Only for testing purposes. Will be removed.")

  # registers a user to a course with a role
  createMembership(input: CourseMembershipInput!): CourseMembership!

  # updates the role of a user in a course
  updateMembership(input: CourseMembershipInput!): CourseMembership!

  # deletes user course link
  deleteMembership(input: CourseMembershipInput!): CourseMembership!

  # Creates a new course with the given input and returns the created course.
  createCourse(input: CreateCourseInput!): Course!

  # Creates a new chapter with the given input and returns the created chapter.
  # The course id must be a course id of an existing course.
  createChapter(input: CreateChapterInput!): Chapter!

  # Updates an existing course with the given input and returns the updated course.
  # The course id must be a course id of an existing course.
  updateCourse(input: UpdateCourseInput!): Course!

  # Updates an existing chapter with the given input and returns the updated chapter.
  # The chapter id must be a chapter id of an existing chapter.
  updateChapter(input: UpdateChapterInput!): Chapter!

  # Deletes an existing course, throws an error if no course with the given id exists.
  deleteCourse(id: UUID!): UUID!

  # Deletes an existing chapter, throws an error if no chapter with the given id exists.
  deleteChapter(id: UUID!): UUID!

  # Creates a new media record
  createMediaRecord(input: CreateMediaRecordInput!): MediaRecord!

  # Updates an existing media record with the given UUID
  updateMediaRecord(input: UpdateMediaRecordInput!): MediaRecord!

  # Deletes the media record with the given UUID
  deleteMediaRecord(id: UUID!): UUID!

  # Allows multiple media records to be linked/added to a content.
  linkMediaRecordsWithContent(
    contentId: UUID!
    mediaRecordIds: [UUID!]!
  ): [MediaRecord!]!

  # Logs that a media has been worked on by the current user.
  # See https://gits-enpro.readthedocs.io/en/latest/dev-manuals/gamification/userProgress.html
  #
  # Possible side effects:
  # When all media records of a content have been worked on by a user,
  # a user-progress event is emitted for the content.
  logMediaRecordWorkedOn(mediaRecordId: UUID!): MediaRecord!

  # Creates a new media content and links the given media records to it.
  createMediaContentAndLinkRecords(
    contentInput: CreateMediaContentInput!
    mediaRecordIds: [UUID!]!
  ): MediaContent!

  # Creates a new quiz assessment and a new, linked quiz with the given properties.
  createQuizAssessment(
    assessmentInput: CreateAssessmentInput!
    quizInput: CreateQuizInput!
  ): QuizAssessment!

  # Creates a new flashcard set assessment and a new, linked flashcard set with the given properties.
  createFlashcardSetAssessment(
    assessmentInput: CreateAssessmentInput!
    flashcardSetInput: CreateFlashcardSetInput!
  ): FlashcardSetAssessment
}

type NumericQuestion implements Question {
  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # The correct answer to the question.
  correctAnswer: Float!

  # The tolerance for the correct answer. The user's answer is correct if it is within the tolerance of the correct answer.
  tolerance: Float!

  # Feedback for the question when the user enters a wrong answer, in SlateJS JSON format.
  feedback: JSON

  # Unique identifier of the question.
  id: UUID!

  # Number of the question, i.e., the position of the question in the list of questions.
  # Only relevant if questionPoolingMode is ORDERED.
  number: Int!

  # Type of the question.
  type: QuestionType!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

# Specifies the page size and page number for paginated results.
input Pagination {
  # The page number, starting at 0.
  # If not specified, the default value is 0.
  # For values greater than 0, the page size must be specified.
  # If this value is larger than the number of pages, an empty page is returned.
  page: Int! = 0

  # The number of elements per page.
  size: Int!
}

# Return type for information about paginated results.
type PaginationInfo {
  # The current page number.
  page: Int!

  # The number of elements per page.
  size: Int!

  # The total number of elements across all pages.
  totalElements: Int!

  # The total number of pages.
  totalPages: Int!

  # Whether there is a next page.
  hasNext: Boolean!
}

type ProgressLogItem {
  # The date the user completed the content item.
  timestamp: DateTime!

  # Whether the user completed the content item successfully.
  success: Boolean!

  # Value between 0 and 1 representing the user's correctness on the content item.
  # Can be null as some contents cannot provide a meaningful correctness value.
  correctness: Float!

  # How many hints the user used to complete the content item.
  hintsUsed: Int!

  # Time in milliseconds it took the user to complete the content item.
  # Can be null for contents that do not measure completion time.
  timeToComplete: Int
}

type PublicUserInfo {
  id: UUID!
  userName: String!
}

type Query {
  # get all contents
  contents: ContentPayload!

  # Get contents by ids. Throws an error if any of the ids are not found.
  contentsByIds(ids: [UUID!]!): [Content!]!

  # Get contents by ids. If any of the given ids are not found, the corresponding element in the result list will be null.
  findContentsByIds(ids: [UUID!]!): [Content]!

  # get contents by chapter ids. Returns a list containing sublists, where each sublist contains all contents
  # associated with that chapter
  contentsByChapterIds(chapterIds: [UUID!]!): [[Content!]!]!

  # Retrieves all existing sections for multiple chapters.
  sectionsByChapterIds(chapterIds: [UUID!]!): [[Section!]!]!

  # Retrieve progress for multiple chapters
  progressByChapterIds(chapterIds: [UUID!]!): [CompositeProgressInformation!]!

  # Generates user specific suggestions for multiple chapters.
  #
  # Only content that the user can access will be considered.
  # The contents will be ranked by suggested date, with the most overdue or most urgent content first.
  suggestionsByChapterIds(
    # The ids of the chapters for which suggestions should be generated.
    chapterIds: [UUID!]!

    # The amount of suggestions to generate in total.
    amount: Int!

    # Only suggestions for these skill types will be generated.
    # If no skill types are given, suggestions for all skill types will be generated,
    # also containing suggestions for media content (which do not have a skill type).
    skillTypes: [SkillType!]! = []
  ): [Suggestion!]!

  # Retrieves all skill types that are achievable for the given chapters.
  # Each chapter will have its own list of skill types (batching query).
  _internal_noauth_achievableSkillTypesByChapterIds(
    chapterIds: [UUID!]!
  ): [[SkillType!]!]!

  # Get the skill levels of the current user for all skill types for a list of chapter ids.
  userSkillLevelsByChapterIds(chapterIds: [UUID!]!): [SkillLevels!]!

  # Get the skill levels of the specified user for all skill types for a list of chapter ids.
  skillLevelsForUserByChapterIds(
    chapterIds: [UUID!]!
    userId: UUID!
  ): [SkillLevels!]!

  # Get quiz by assessment ID.
  # If any of the assessment IDs are not found, the corresponding quiz will be null.
  findQuizzesByAssessmentIds(assessmentIds: [UUID!]!): [Quiz]!

  # Get flashcards by their ids
  flashcardsByIds(ids: [UUID!]!): [Flashcard!]!

  # Get flashcard sets by their assessment ids.
  # Returns a list of flashcard sets in the same order as the provided ids.
  # Each element is null if the corresponding id is not found.
  findFlashcardSetsByAssessmentIds(assessmentIds: [UUID!]!): [FlashcardSet]!

  # Get the reward score of the current user for the specified course.
  userCourseRewardScores(courseId: UUID!): RewardScores!

  # Get the reward score of the specified user for the specified course.
  courseRewardScoresForUser(courseId: UUID!, userId: UUID!): RewardScores!

  # Gets the power scores for each user in the course, ordered by power score descending.
  scoreboard(courseId: UUID!): [ScoreboardItem!]!

  # Gets the publicly available information for a list of users with the specified IDs.
  # If a user does not exist, null is returned for that user.
  findPublicUserInfos(ids: [UUID!]!): [PublicUserInfo]!

  # Gets the user information of the currently authorized user.
  currentUserInfo: UserInfo!

  # Gets all of the users' information for a list of users with the specified IDs.
  # Only available to privileged users.
  # If a user does not exist, null is returned for that user.
  findUserInfos(ids: [UUID!]!): [UserInfo]!

  # Get a list of courses. Can be filtered, sorted and paginated.
  courses(
    filter: CourseFilter

    # The fields to sort by.
    # Throws an error if no field with the given name exists.
    sortBy: [String!]

    # The sort direction for each field. If not specified, defaults to ASC.
    sortDirection: [SortDirection!]! = [ASC]
    pagination: Pagination
  ): CoursePayload!

  # Returns the courses with the given ids.
  coursesByIds(ids: [UUID!]!): [Course!]!

  # Returns the chapters with the given ids.
  chaptersByIds(ids: [UUID!]!): [Chapter!]!

  # Returns a set of Resource Objects for the given resource ids, containing a
  # list of all course IDs for a resource and its availability in the course.
  courseResourceAssociationsByIds(ids: [UUID!]!): [CourseResourceAssociation!]!

  # Returns a set of Resource Objects for the given resource ids, containing a
  # list of all course IDs for a resource and its availability in the course.
  resourceById(ids: [UUID!]!): [CourseResourceAssociation!]!
    @deprecated(reason: "Use courseResourceAssociationsByIds instead.")

  # Get the list of chapters for a course. Can be filtered, sorted and paginated.
  # Throws an error if the course does not exist.
  # The default sort order is by chapter number.
  chapters(
    courseId: UUID!
    filter: ChapterFilter

    # The fields to sort by. The default sort order is by chapter number.
    # Throws an error if no field with the given name exists.
    sortBy: [String!]! = []

    # The sort direction for each field. If not specified, defaults to ASC.
    sortDirection: [SortDirection!]! = [ASC]
    pagination: Pagination
  ): ChapterPayload!

  # Returns the media records with the given IDs. Throws an error if a MediaRecord corresponding to a given ID
  # cannot be found.
  mediaRecordsByIds(ids: [UUID!]!): [MediaRecord!]!

  # Like mediaRecordsByIds() returns the media records with the given IDs, but instead of throwing an error if an ID
  # cannot be found, it instead returns NULL for that media record.
  findMediaRecordsByIds(ids: [UUID!]!): [MediaRecord]!

  # Returns all media records of the system.
  mediaRecords: [MediaRecord!]!
    @deprecated(
      reason: "In production there should probably be no way to get all media records of the system."
    )

  # Returns all media records which the current user created.
  userMediaRecords: [MediaRecord!]!

  # Returns the media records associated the given content IDs as a list of lists where each sublist contains
  # the media records associated with the content ID at the same index in the input list
  mediaRecordsByContentIds(contentIds: [UUID!]!): [[MediaRecord!]!]!
}

# Generic question interface.
interface Question {
  # Unique identifier of the question.
  id: UUID!

  # Number of the question, i.e., the position of the question in the list of questions.
  # Only relevant if questionPoolingMode is ORDERED.
  number: Int!

  # Type of the question.
  type: QuestionType!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

input QuestionCompletedInput {
  # ID of the question.
  questionId: UUID!

  # true when question was answered correctly
  correct: Boolean!

  # true when a hint was used for the question
  usedHint: Boolean!
}

enum QuestionPoolingMode {
  # Questions are randomly selected from the list of questions.
  RANDOM

  # Questions are selected in order from the list of questions.
  ORDERED
}

# The type of a question.
enum QuestionType {
  MULTIPLE_CHOICE
  CLOZE
  ASSOCIATION
  EXACT_ANSWER
  NUMERIC
  SELF_ASSESSMENT
}

# A quiz is a set of questions that the user has to answer correctly to pass the quiz.
# Questions can be of different types, e.g., multiple choice, clozes, or open questions.
type Quiz {
  # Identifier of the quiz, same as the identifier of the assessment.
  assessmentId: UUID!

  # List of questions.
  questionPool: [Question!]!

  # Threshold of the quiz, i.e., how many questions the user has to answer correctly to pass the quiz.
  # If this number is greater than the number of questions, the behavior is the same
  # as if it was equal to the number of questions.
  requiredCorrectAnswers: Int!

  # Question pooling mode of the quiz.
  questionPoolingMode: QuestionPoolingMode!

  # Number of questions that are randomly selected from the list of questions.
  # Will only be considered if questionPoolingMode is RANDOM.
  #
  # If this is greater than the number of questions, the behavior is the same
  # as if it was equal to the number of questions.
  #
  # If this is null or not set, the behavior is the same as if it was equal to the number of questions.
  numberOfRandomlySelectedQuestions: Int

  # The selected questions of the question pool.
  # This is identical to the list of questions if questionPoolingMode is ORDERED.
  # This will be different each time it is queried if questionPoolingMode is RANDOM.
  selectedQuestions: [Question!]!

  # The assessment this quiz belongs to.
  assessment: QuizAssessment
}

# A quiz, quiz related fields are stored in the quiz service.
type QuizAssessment implements Assessment & Content {
  # Assessment metadata
  assessmentMetadata: AssessmentMetadata!

  # ID of the content
  id: UUID!

  # Metadata of the content
  metadata: ContentMetadata!

  # Progress data of the content for the current user.
  userProgressData: UserProgressData!

  # Progress data of the specified user.
  progressDataForUser(userId: UUID!): UserProgressData!

  # The quiz of the assessment.
  # If this is null the system is in an inconsistent state and the assessment should be deleted.
  quiz: Quiz
}

input QuizCompletedInput {
  # ID of the quiz.
  quizId: UUID!

  # List of questions that were answered in the quiz.
  completedQuestions: [QuestionCompletedInput!]!
}

type QuizMutation {
  # Id of the quiz to modify.
  assessmentId: UUID!

  # Add a multiple choice question to the quiz questions, at the end of the list.
  addMultipleChoiceQuestion(input: CreateMultipleChoiceQuestionInput!): Quiz!

  # Update a multiple choice question in the quiz questions.
  updateMultipleChoiceQuestion(input: UpdateMultipleChoiceQuestionInput!): Quiz!

  # Add a cloze question to the quiz questions, at the end of the list.
  addClozeQuestion(input: CreateClozeQuestionInput!): Quiz!

  # Update a cloze question in the quiz questions.
  updateClozeQuestion(input: UpdateClozeQuestionInput!): Quiz!

  # Add an association question to the quiz questions, at the end of the list.
  addAssociationQuestion(input: CreateAssociationQuestionInput!): Quiz!

  # Update an association question in the quiz questions.
  updateAssociationQuestion(input: UpdateAssociationQuestionInput!): Quiz!

  # Add an free text question with exact answer to the quiz questions, at the end of the list.
  addExactAnswerQuestion(input: CreateExactAnswerQuestionInput!): Quiz!

  # Update an free text question with exact answer in the quiz questions.
  updateExactAnswerQuestion(input: UpdateExactAnswerQuestionInput!): Quiz!

  # Add a numeric question to the quiz questions, at the end of the list.
  addNumericQuestion(input: CreateNumericQuestionInput!): Quiz!

  # Update a numeric question in the quiz questions.
  updateNumericQuestion(input: UpdateNumericQuestionInput!): Quiz!

  # Add a self assessment question to the quiz questions, at the end of the list.
  addSelfAssessmentQuestion(input: CreateSelfAssessmentQuestionInput!): Quiz!

  # Update a self assessment question in the quiz questions.
  updateSelfAssessmentQuestion(input: UpdateSelfAssessmentQuestionInput!): Quiz!

  # Removes the question with the given number from the quiz.
  # This will also update the numbers of the following questions.
  removeQuestion(number: Int!): Quiz!

  # Switch the position of two questions with the given numbers.
  switchQuestions(firstNumber: Int!, secondNumber: Int!): Quiz!

  # Set the threshold of the quiz, i.e., how many questions the user has to answer correctly to pass the quiz.
  setRequiredCorrectAnswers(requiredCorrectAnswers: Int!): Quiz!

  # Set the question pooling mode of the quiz.
  setQuestionPoolingMode(questionPoolingMode: QuestionPoolingMode!): Quiz!

  # Set the number of questions that are randomly selected from the list of questions.
  # Will only be considered if questionPoolingMode is RANDOM.
  setNumberOfRandomlySelectedQuestions(
    numberOfRandomlySelectedQuestions: Int!
  ): Quiz!
}

scalar ResolveToSourceArgs

type ResourceMarkdown {
  # The raw ResourceMarkdown text.
  text: String!

  # Ids of MediaRecords referenced in the ResourceMarkdown text in order.
  referencedMediaRecordIds: [UUID!]!

  # Resolved MediaRecords referenced in the ResourceMarkdown text in order.
  # A MediaRecord might be NULL if the referenced MediaRecord no longer exists.
  referencedMediaRecords: [MediaRecord]!
}

input ResourceMarkdownInput {
  # The raw ResourceMarkdown text.
  text: String!
}

# The reason why the reward score has changed.
enum RewardChangeReason {
  # The user has completed a content for the first time.
  # The associated contents are the content that were completed.
  CONTENT_DONE

  # The user has reviewed a content.
  # The associated contents are the content that were reviewed.
  CONTENT_REVIEWED

  # There exists a content that is due for learning.
  # The associated contents are the content that are due for learning.
  CONTENT_DUE_FOR_LEARNING

  # There exists a content that is due for repetition.
  # The associated contents are the content that are due for repetition.
  CONTENT_DUE_FOR_REPETITION

  # The score changed because the underlying scores changed.
  # Relevant for the power score.
  COMPOSITE_VALUE
}

# An item in the reward score log.
type RewardLogItem {
  # The date when the reward score changed.
  date: DateTime!

  # The difference between the previous and the new reward score.
  difference: Int!

  # The old reward score.
  oldValue: Int!

  # The new reward score.
  newValue: Int!

  # The reason why the reward score has changed.
  reason: RewardChangeReason!

  # The ids of the contents that are associated with the change.
  associatedContentIds: [UUID!]!
  associatedContents: [Content]!
}

# The reward score of a user.
type RewardScore {
  # The absolute value of the reward score.
  # Health and fitness are between 0 and 100.
  # Growth, strength and power can be any non-negative integer.
  value: Int!

  # The relative value of the reward score.
  # Shows how many points relative to the total points have been achieved.
  # Only used for growth currently.
  percentage: Float!

  # A log of the changes to the reward score, ordered by date descending.
  log: [RewardLogItem!]!
}

# The five reward scores of a user.
type RewardScores {
  # Health represents how up-to-date the user is with the course.
  health: RewardScore!

  # Fitness represents how well the user repeats previously learned content.
  fitness: RewardScore!

  # Growth represents the overall progress of the user.
  growth: RewardScore!

  # Strength is earned by competing with other users.
  strength: RewardScore!

  # A composite score of all the other scores.
  power: RewardScore!
}

# An item in the scoreboard.
type ScoreboardItem {
  # The user id of the user.
  userId: UUID!

  # The power score of the user.
  powerScore: Int!
  user: PublicUserInfo
}

# Representation of a Section
type Section {
  # Unique identifier of the Section Object
  id: UUID!

  # Name of the Section
  name: String!

  # Chapter the Section is located in
  chapterId: UUID!

  # List of Stages contained in a Section
  stages: [Stage!]!
  chapter: Chapter!
}

type SectionMutation {
  # Identifier of the section
  sectionId: UUID!

  # update the name of a Section
  updateSectionName(name: String!): Section!

  # delete a Section by ID
  deleteSection: UUID!

  # create new Stage in Section
  createStage(input: CreateStageInput): Stage!

  # Update Content of Stage
  updateStage(input: UpdateStageInput): Stage!

  # delete Stage by ID
  deleteStage(id: UUID!): UUID!

  # update Order of Stages within a Section
  updateStageOrder(stages: [UUID!]!): Section!
}

# A single question with a free text answer field, where the answer is not automatically checked.
# The user has to enter a solution and self-assess whether it is correct or not.
# This is useful for questions where the answer is not clear-cut, e.g. when the user should explain a concept.
type SelfAssessmentQuestion implements Question {
  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # A possible correct answer to the question.
  solutionSuggestion: JSON!

  # Unique identifier of the question.
  id: UUID!

  # Number of the question, i.e., the position of the question in the list of questions.
  # Only relevant if questionPoolingMode is ORDERED.
  number: Int!

  # Type of the question.
  type: QuestionType!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

type SingleAssociation {
  # The left side of the association.
  left: String!

  # The right side of the association.
  right: String!

  # Feedback for the association when the user assigns a wrong answer, in SlateJS JSON format.
  feedback: JSON
}

# The skill level of a user.
type SkillLevel {
  # The value of the skill level.
  # levels are between 0 and 100.
  value: Float!

  # A log of the changes to the skill level
  log: [SkillLevelLogItem!]!
}

# An item in the skill level change log.
type SkillLevelLogItem {
  # The date when the skill level changed.
  date: DateTime!

  # The difference between the previous and the new skill level.
  difference: Float!

  # The old skill level.
  oldValue: Float!

  # The new skill level.
  newValue: Float!

  # The ids of the contents that are associated with the change.
  associatedContentIds: [UUID!]!
  associatedContents: [Content]!
}

# The four skill level of a user.
type SkillLevels {
  # remember represents how much user remember the concept
  remember: SkillLevel!

  # understand represents how well the user understands learned content.
  understand: SkillLevel!

  # apply represents the how well user applies the learned concept during assessment.
  apply: SkillLevel!

  # apply is how much user can evaluate information and draw conclusions
  analyze: SkillLevel!
}

# Type of the assessment
enum SkillType {
  REMEMBER
  UNDERSTAND
  APPLY
  ANALYSE
}

# Specifies the sort direction, either ascending or descending.
enum SortDirection {
  ASC
  DESC
}

# Representation of a Stage
type Stage {
  # Unique identifier of the Stage Object
  id: UUID!

  # Position of the Stage within the Section
  position: Int!

  # List of Content that is labeled as required content
  requiredContents: [Content!]!

  # Percentage of User Progress made to required Content
  requiredContentsProgress: Float!

  # List of Content that is labeled as optional content
  optionalContents: [Content!]!

  # Percentage of Progress made to optional Content
  optionalContentsProgress: Float!
}

# Filter for string values.
# If multiple filters are specified, they are combined with AND.
input StringFilter {
  # A string value to match exactly.
  equals: String

  # A string value that must be contained in the field that is being filtered.
  contains: String

  # If true, the filter is case-insensitive.
  ignoreCase: Boolean! = false
}

# Represents a suggestion for a user to learn new content or review old content.
type Suggestion {
  # The content that is suggested to the user.
  content: Content!

  # The type of suggestion.
  type: SuggestionType!
}

enum SuggestionType {
  NEW_CONTENT
  REPETITION
}

# An RFC-3339 compliant Full Time Scalar
scalar Time

input UpdateAssessmentInput {
  # Metadata for the new Content
  metadata: UpdateContentMetadataInput!

  # Assessment metadata
  assessmentMetadata: AssessmentMetadataInput!
}

input UpdateAssociationQuestionInput {
  # UUID of the question to update.
  id: UUID!

  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # List of associations.
  correctAssociations: [AssociationInput!]!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

# Input type for updating chapters.
# The ID field specifies which chapter should be updated, all other fields specify the new values.
input UpdateChapterInput {
  # UUID of the chapter that should be updated.
  id: UUID!

  # Title of the chapter, maximum length is 255 characters, must not be blank.
  title: String!

  # Description of the chapter, maximum length is 3000 characters.
  description: String!

  # Number of the chapter, determines the order of the chapters, must be positive.
  number: Int!

  # Start date of the chapter, ISO 8601 format.
  # Must be before the end date.
  startDate: DateTime!

  # End date of the chapter, ISO 8601 format.
  # Must be after the start date.
  endDate: DateTime!

  # Suggested Start date to start the chapter, ISO 8601 format.
  # Must be after Start Date and before the End dates.
  suggestedStartDate: DateTime

  # Suggested End date of the chapter, ISO 8601 format.
  # Must be after the Start Dates and before the End dates.
  suggestedEndDate: DateTime
}

input UpdateClozeQuestionInput {
  # UUID of the question to update.
  id: UUID!

  # List of cloze elements.
  clozeElements: [ClozeElementInput!]!

  # List of additional wrong answers.
  additionalWrongAnswers: [String!]!

  # If true, the list of possible answers will be shown to the user.
  showBlanksList: Boolean! = true

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

input UpdateContentMetadataInput {
  # Name of the content
  name: String!

  # Date when the content should be done
  suggestedDate: DateTime!

  # Number of reward points a student receives for completing this content
  rewardPoints: Int!

  # ID of the chapter this content is associated with
  chapterId: UUID!

  # TagNames this content is tagged with
  tagNames: [String!]! = []
}

# Input type for updating an existing course. See also on the course type for detailed field descriptions.
# The id specifies the course that should be updated, the other fields specify the new values.
input UpdateCourseInput {
  # UUID of the course that should be updated.
  # Must be an id of an existing course, otherwise an error is returned.
  id: UUID!

  # The new title of the course, max 255 characters, must not be blank.
  title: String!

  # The new description of the course, max 3000 characters.
  description: String!

  # The new start date of the course, ISO 8601 format.
  startDate: DateTime!

  # The new end date of the course, ISO 8601 format.
  endDate: DateTime!

  # The new published status of the course.
  published: Boolean!
}

input UpdateExactAnswerQuestionInput {
  # UUID of the question to update.
  id: UUID!

  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # A list of possible correct answers.
  correctAnswers: [String!]!

  # If the answer is case sensitive. If true, the answer is checked case sensitive.
  caseSensitive: Boolean! = false

  # Feedback for the question when the user enters a wrong answer, in SlateJS JSON format.
  feedback: JSON

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

input UpdateFlashcardInput {
  # Id of the flashcard to update.
  id: UUID!

  # List of sides of this flashcard. Must be at least two sides.
  sides: [FlashcardSideInput!]!
}

input UpdateMediaContentInput {
  # Metadata for the new Content
  metadata: UpdateContentMetadataInput!
}

input UpdateMediaRecordInput {
  # ID of the media record which should be updated
  id: UUID!

  # New name of the media record. Cannot be blank, maximum length 255 characters.
  name: String!

  # New type of the media record.
  type: MediaType!

  # IDs of the MediaContents this media record is associated with
  contentIds: [UUID!]!
}

input UpdateMultipleChoiceQuestionInput {
  # UUID of the question to update.
  id: UUID!

  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # List of answers.
  answers: [MultipleChoiceAnswerInput!]!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

input UpdateNumericQuestionInput {
  # UUID of the question to update.
  id: UUID!

  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # The correct answer for the question.
  correctAnswer: Float!

  # The allowed deviation from the correct answer.
  tolerance: Float!

  # Feedback for the question when the user enters a wrong answer, in SlateJS JSON format.
  feedback: JSON

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

input UpdateSelfAssessmentQuestionInput {
  # UUID of the question to update.
  id: UUID!

  # Text of the question, in SlateJS JSON format.
  text: JSON!

  # A possible correct answer to the question.
  solutionSuggestion: JSON!

  # Optional hint for the question, in SlateJS JSON format.
  hint: JSON
}

input UpdateStageInput {
  # Identifier of the Stage
  id: UUID!

  # updated List of UUIDs for content labeled as required in this Stage
  requiredContents: [UUID!]!

  # updated List of UUIDs for content labeled as optional in this Stage
  optionalContents: [UUID!]!
}

# A Url scalar
scalar Url

type UserInfo {
  id: UUID!
  userName: String!
  firstName: String!
  lastName: String!
  courseMemberships: [CourseMembership!]!
}

# Represents a user's progress on a content item.
# See https://gits-enpro.readthedocs.io/en/latest/dev-manuals/gamification/userProgress.html
type UserProgressData {
  # The user's id.
  userId: UUID!

  # The id of the content item.
  contentId: UUID!

  # A list of entries each representing the user completing the content item.
  # Sorted by date in descending order.
  log: [ProgressLogItem]!

  # The learning interval in days for the content item.
  # If null, the content item is not scheduled for learning.
  learningInterval: Int

  # The next time the content should be learned.
  # Calculated using the date the user completed the content item and the learning interval.
  # This is null if the user has not completed the content item once.
  nextLearnDate: DateTime

  # The last time the content was learned successfully.
  # This is null if the user has not completed the content item once.
  lastLearnDate: DateTime

  # True if the user has completed the content item at least once successfully.
  isLearned: Boolean!

  # True if the assessment is due for review.
  isDueForReview: Boolean!
}

# Enum containing all valid roles a user can have in a course.
enum UserRoleInCourse {
  STUDENT
  TUTOR
  ADMINISTRATOR
}

# A universally unique identifier compliant UUID Scalar
scalar UUID

# The division of the academic year.
enum YearDivision {
  FIRST_SEMESTER
  SECOND_SEMESTER
  FIRST_TRIMESTER
  SECOND_TRIMESTER
  THIRD_TRIMESTER
  FIRST_QUARTER
  SECOND_QUARTER
  THIRD_QUARTER
  FOURTH_QUARTER
}
